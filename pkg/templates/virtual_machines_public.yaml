id: virtual_machines_public_access
name: Virtual Machines with Public IP
category: ["Public Access", "arg-scan"]
description: Detects virtual machines with public IPs, evaluating NSG protection status and open ports. VMs without NSGs are flagged as most vulnerable, especially with Basic SKU public IPs (default open).
severity: High
reportability: Automatic
triageNotes: |
  Manual review required to assess exposure risk:

  Understanding openPorts Field:
  - "all (no NSG - Basic SKU default open)" = CRITICAL: No firewall protection, all ports exposed to internet
  - "all (no NSG)" = CRITICAL: No firewall protection, exposure depends on IP SKU
  - "none (no NSG - Standard SKU secure by default)" = HIGH: No firewall but Standard SKU blocks inbound by default
  - Specific ports (e.g., ["22","443"]) = HIGH: Named ports exposed through NSG allow rules
  - "none" = LOW: Has NSG but no inbound allow rules, still has unnecessary public IP

  Public IP SKU Behavior:
  - Basic SKU: Open by default - no NSG means ALL ports exposed (retired Sept 2025 but still operational)
  - Standard SKU: Secure by default - no NSG still blocks inbound traffic (requires explicit NSG rules)

  Triage Priority:
  1. CRITICAL: hasNSG=false + Basic SKU - Add NSG immediately, all ports exposed
  2. HIGH: hasNSG=false + Standard SKU - Add NSG for defense in depth
  3. HIGH: hasNSG=true + specific open ports - Review if ports need internet exposure, scan and test for vulnerabilities
  4. LOW: hasNSG=true + openPorts="none" - Review if public IP is necessary

  Remediation:
  - For no-NSG VMs: Create and attach NSG with restrictive inbound rules
  - For VMs with open ports: Tighten NSG rules to minimum required access
  - Best practice: Remove public IPs entirely, use Azure Bastion, load balancers, or Application Gateway instead
references:
  - https://learn.microsoft.com/en-us/azure/virtual-machines/network-overview
query: |
  resources
  | where type =~ 'Microsoft.Compute/virtualMachines'
  | extend vmId = id, vmName = name, vmLocation = location
  | extend osType = properties.storageProfile.osDisk.osType
  | mv-expand nic = properties.networkProfile.networkInterfaces
  | extend nicId = tostring(nic.id)
  // Join with network interfaces to find public IPs
  | join kind=inner (
      resources
      | where type =~ 'Microsoft.Network/networkInterfaces'
      | extend nicId = id
      | extend nicNsgId = tostring(properties.networkSecurityGroup.id)
      | mv-expand ipconfig = properties.ipConfigurations
      | extend subnetId = tostring(ipconfig.properties.subnet.id)
      | extend publicIPId = tostring(ipconfig.properties.publicIPAddress.id)
      | extend privateIP = tostring(ipconfig.properties.privateIPAddress)
      | where isnotempty(publicIPId)
      // Join with public IPs to get the actual IP address and SKU
      | join kind=inner (
          resources
          | where type =~ 'Microsoft.Network/publicIPAddresses'
          | where isnotempty(properties.ipAddress)
          | project publicIPId = id, publicIP = tostring(properties.ipAddress), publicIPSku = tostring(sku.name)
      ) on $left.publicIPId == $right.publicIPId
      | project nicId, publicIP, privateIP, nicNsgId, subnetId, publicIPSku
  ) on $left.nicId == $right.nicId
  // First summarize to get VM-level data
  | summarize
      publicIPs = make_set(publicIP),
      privateIPs = make_set(privateIP),
      publicIPSkus = make_set(publicIPSku),
      nicNsgIds = make_set(nicNsgId),
      subnetIds = make_set(subnetId),
      osType = any(osType)
      by vmId, vmName, vmLocation
  // Get all NSGs (from all NICs of the VM, not just the one with public IP)
  | join kind=leftouter (
      resources
      | where type =~ 'Microsoft.Compute/virtualMachines'
      | mv-expand nic = properties.networkProfile.networkInterfaces
      | extend nicId = tostring(nic.id)
      | join kind=inner (
          resources
          | where type =~ 'Microsoft.Network/networkInterfaces'
          | extend nicId = id
          | extend nicNsgId = tostring(properties.networkSecurityGroup.id)
          | where isnotempty(nicNsgId)
          | project nicId, nicNsgId
      ) on $left.nicId == $right.nicId
      | summarize allVmNicNsgIds = make_set(nicNsgId) by vmId = id
  ) on $left.vmId == $right.vmId
  | extend nicNsgIds = coalesce(allVmNicNsgIds, nicNsgIds)
  // Expand subnet IDs to check for subnet-level NSGs
  | mv-expand subnetId = subnetIds to typeof(string)
  | join kind=leftouter (
      resources
      | where type =~ 'Microsoft.Network/virtualNetworks'
      | mv-expand subnet = properties.subnets
      | extend subnetId = tostring(subnet.id)
      | extend subnetNsgId = tostring(subnet.properties.networkSecurityGroup.id)
      | where isnotempty(subnetNsgId)
      | project subnetId, subnetNsgId
  ) on $left.subnetId == $right.subnetId
  // Re-aggregate after subnet join
  | summarize
      publicIPs = make_set(publicIPs),
      privateIPs = make_set(privateIPs),
      publicIPSkus = make_set(publicIPSkus),
      nicNsgIds = make_set(nicNsgIds),
      subnetNsgIds = make_set(subnetNsgId),
      osType = any(osType)
      by vmId, vmName, vmLocation
  | extend allNsgIds = set_union(nicNsgIds, subnetNsgIds)
  // Now get ports - but don't filter out VMs without NSGs yet
  | mv-expand nsgId = allNsgIds to typeof(string)
  | join kind=leftouter (
      resources
      | where type =~ 'Microsoft.Network/networkSecurityGroups'
      | mv-expand rule = properties.securityRules
      | where rule.properties.direction == 'Inbound' 
      | where rule.properties.access == 'Allow'
      | extend sourcePrefix = tostring(rule.properties.sourceAddressPrefix)
      | extend sourcePrefixes = rule.properties.sourceAddressPrefixes
      // Check if source allows internet traffic
      | where sourcePrefix in ('*', 'Internet', '0.0.0.0', '0.0.0.0/0')
          or sourcePrefixes has '*' 
          or sourcePrefixes has 'Internet' 
          or sourcePrefixes has '0.0.0.0/0'
      | extend destPort = tostring(rule.properties.destinationPortRange)
      | extend destPorts = rule.properties.destinationPortRanges
      // Handle both single ports and port arrays
      | extend ports = case(
          isnotempty(destPort), pack_array(destPort),
          isnotempty(destPorts), destPorts,
          pack_array('*')
      )
      | mv-expand port = ports to typeof(string)
      | summarize openPorts = make_set(port) by nsgId = id
  ) on $left.nsgId == $right.nsgId
  // Final aggregation - include ALL VMs (with or without NSGs)
  | summarize
      publicIPs = make_set(publicIPs),
      privateIPs = make_set(privateIPs),
      publicIPSkus = make_set(publicIPSkus),
      allOpenPorts = make_set(openPorts),
      nsgCount = dcountif(nsgId, isnotempty(nsgId)),
      osType = any(osType)
      by vmId, vmName, vmLocation
  // Determine NSG protection status
  | extend hasNSG = (nsgCount > 0)
  | extend hasBasicSku = (publicIPSkus has "Basic" or publicIPSkus has "basic")
  | extend hasStandardSku = (publicIPSkus has "Standard" or publicIPSkus has "standard")
  // Format openPorts based on NSG status and Public IP SKU
  | extend openPorts = case(
      not(hasNSG) and hasBasicSku, "all (no NSG - Basic SKU default open)",
      not(hasNSG) and hasStandardSku, "none (no NSG - Standard SKU secure by default)",
      not(hasNSG), "all (no NSG)",
      isempty(allOpenPorts) or array_length(allOpenPorts) == 0, "none",
      tostring(allOpenPorts)
  )
  // Format the output
  | project
      name = vmName,
      location = vmLocation,
      publicIPs = tostring(publicIPs),
      privateIPs = tostring(privateIPs),
      openPorts,
      hasNSG,
      publicIPSku = tostring(publicIPSkus)
