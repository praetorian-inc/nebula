package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

// Command line flags
var (
	modulesDir     = flag.String("modules", "pkg/modules/", "Directory containing module files with build tags")
	cmdDir         = flag.String("cmd", "cmd/", "Directory containing command files to update")
	updateMakefile = flag.Bool("update-makefile", true, "Update the Makefile with the detected tags")
	updateCmdFiles = flag.Bool("update-cmd", true, "Update the cmd files with appropriate tags")
	makefilePath   = flag.String("makefile", "Makefile", "Path to the Makefile")
)

// Tag represents a build tag and its dependencies
type Tag struct {
	Name         string
	Dependencies []string
	Files        []string
	Platform     string
	Category     string
}

// Regular expression to match build tag lines
var buildTagRegex = regexp.MustCompile(`^//go:build\s+(.+)$`)

// Module represents module registration information
type Module struct {
	Platform  string
	Category  string
	Name      string
	FilePath  string
	BuildTags []string
}

// Regular expression to match registry.Register calls
var registerRegex = regexp.MustCompile(`registry\.Register\s*\(\s*"([^"]+)"\s*,\s*"([^"]+)"\s*,\s*"([^"]+)"\s*,`)

func main() {
	flag.Parse()

	// Find all modules by scanning for registry.Register calls
	modules, err := findModuleRegistrations(*modulesDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error scanning modules directory: %v\n", err)
		os.Exit(1)
	}

	// Print discovered modules
	fmt.Println("Discovered modules:")
	for _, module := range modules {
		fmt.Printf("- %s/%s/%s (tags: %s)\n",
			module.Platform,
			module.Category,
			module.Name,
			strings.Join(module.BuildTags, ", "))
	}

	// Update Makefile if requested
	if *updateMakefile {
		err := updateMakefileWithModules(*makefilePath, modules)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error updating Makefile: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("Successfully updated Makefile with build tags")
	}

	// Update cmd files if requested
	if *updateCmdFiles {
		err := updateCmdFilesFromModules(*cmdDir, modules)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error updating cmd files: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("Successfully updated cmd files with build tags")
	}
}

// findModuleRegistrations scans files for registry.Register calls and extract module info
func findModuleRegistrations(dir string) ([]Module, error) {
	var modules []Module

	err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Skip non-Go files
		if !strings.HasSuffix(path, ".go") || d.IsDir() {
			return nil
		}

		// Read the file content
		content, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		fileContent := string(content)

		// Extract build tags
		buildTags := extractBuildTags(fileContent)

		// Look for registry.Register calls
		matches := registerRegex.FindAllStringSubmatch(fileContent, -1)
		for _, match := range matches {
			if len(match) >= 4 {
				// If build tags are empty and we're in a module, infer standard tags
				if len(buildTags) == 0 {
					platform := match[1]
					category := match[2]
					name := match[3]

					// Standard tags pattern
					buildTags = []string{
						platform,                               // e.g., "aws"
						platform + "_" + category,              // e.g., "aws_recon"
						platform + "_" + category + "_" + name, // e.g., "aws_recon_find_secrets"
						"all",
					}
				}

				module := Module{
					Platform:  match[1],
					Category:  match[2],
					Name:      match[3],
					FilePath:  path,
					BuildTags: buildTags,
				}
				modules = append(modules, module)
			}
		}

		return nil
	})

	return modules, err
}

// extractBuildTags extracts the build tags from a file
func extractBuildTags(content string) []string {
	var buildTags []string

	// Find the build tag line
	matches := buildTagRegex.FindStringSubmatch(content)
	if len(matches) > 1 {
		// Split by logical OR
		tagExpr := matches[1]
		parts := strings.Split(tagExpr, "||")

		// Trim each tag
		for _, part := range parts {
			tag := strings.TrimSpace(part)
			if tag != "" {
				buildTags = append(buildTags, tag)
			}
		}
	}

	return buildTags
}

// Makefile template
const makefileTemplate = `# Generated by tag-updater. DO NOT EDIT MANUALLY.
.PHONY: all clean {{range .Platforms}}{{.}} {{end}}{{range .Categories}}{{.}} {{end}}build_all

# Default build directory
BIN_DIR := bin

# All available platforms
PLATFORMS := {{range $i, $platform := .Platforms}}{{if $i}} {{end}}{{$platform}}{{end}}

# All available categories
CATEGORIES := {{range $i, $category := .Categories}}{{if $i}} {{end}}{{$category}}{{end}}

# Ensure the bin directory exists
$(BIN_DIR):
	mkdir -p $(BIN_DIR)

# Build all modules
all: all_modules

# Build all modules with the 'all' tag
all_modules: $(BIN_DIR)
	go build -tags all -o $(BIN_DIR)/nebula-all main.go

# Build all sub-builds with each individual tag
build_all: $(BIN_DIR) $(PLATFORMS) $(CATEGORIES)
	@echo "All builds completed successfully."

{{range .Platforms}}# Build {{.}} modules
{{.}}: $(BIN_DIR)
	go build -tags {{.}} -o $(BIN_DIR)/nebula-{{.}} main.go

{{end}}{{range .PlatformCategories}}# Build {{.Platform}}_{{.Category}} modules
{{.Platform}}_{{.Category}}: $(BIN_DIR)
	go build -tags {{.Platform}}_{{.Category}} -o $(BIN_DIR)/nebula-{{.Platform}}-{{.Category}} main.go

{{end}}# Clean the build directory
clean:
	rm -rf $(BIN_DIR)
`

// PlatformCategory represents a platform and category combination
type PlatformCategory struct {
	Platform string
	Category string
}

// MakefileData holds data for the Makefile template
type MakefileData struct {
	Platforms          []string
	Categories         []string
	PlatformCategories []PlatformCategory
}

// updateMakefileWithModules updates the Makefile with module information
func updateMakefileWithModules(makefilePath string, modules []Module) error {
	// Extract unique platforms and categories
	platformMap := make(map[string]bool)
	categoryMap := make(map[string]bool)
	platformCategoryMap := make(map[string]map[string]bool)

	for _, module := range modules {
		platformMap[module.Platform] = true
		categoryMap[module.Category] = true

		if _, exists := platformCategoryMap[module.Platform]; !exists {
			platformCategoryMap[module.Platform] = make(map[string]bool)
		}
		platformCategoryMap[module.Platform][module.Category] = true
	}

	// Convert to sorted slices
	var platforms []string
	for platform := range platformMap {
		platforms = append(platforms, platform)
	}
	sort.Strings(platforms)

	var categories []string
	for category := range categoryMap {
		categories = append(categories, category)
	}
	sort.Strings(categories)

	// Create platform-category combinations
	var platformCategories []PlatformCategory
	for platform, categories := range platformCategoryMap {
		for category := range categories {
			platformCategories = append(platformCategories, PlatformCategory{
				Platform: platform,
				Category: category,
			})
		}
	}

	// Sort platform-category combinations
	sort.Slice(platformCategories, func(i, j int) bool {
		if platformCategories[i].Platform != platformCategories[j].Platform {
			return platformCategories[i].Platform < platformCategories[j].Platform
		}
		return platformCategories[i].Category < platformCategories[j].Category
	})

	// Create a new file
	file, err := os.Create(makefilePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Prepare data for template
	data := MakefileData{
		Platforms:          platforms,
		Categories:         categories,
		PlatformCategories: platformCategories,
	}

	// Parse and execute the template
	tmpl, err := template.New("makefile").Parse(makefileTemplate)
	if err != nil {
		return err
	}

	return tmpl.Execute(file, data)
}

// cmdFileTemplate is the template for cmd files
const cmdFileTemplate = `//go:build {{.TagExpr}}

package cmd

import (
	_ "github.com/praetorian-inc/nebula/pkg/modules/{{.Platform}}/{{.Category}}"
)
`

// updateCmdFilesFromModules updates the cmd files based on module information
func updateCmdFilesFromModules(cmdDir string, modules []Module) error {
	// Group modules by platform and category
	platformCategoryModules := make(map[string]map[string][]Module)

	for _, module := range modules {
		// Skip invalid modules
		if module.Platform == "" || module.Category == "" {
			continue
		}

		if _, exists := platformCategoryModules[module.Platform]; !exists {
			platformCategoryModules[module.Platform] = make(map[string][]Module)
		}

		platformCategoryModules[module.Platform][module.Category] = append(
			platformCategoryModules[module.Platform][module.Category],
			module,
		)
	}

	// Ensure cmd directory exists
	if err := os.MkdirAll(cmdDir, 0755); err != nil {
		return err
	}

	// Create or update cmd files for each platform/category
	for platform, categories := range platformCategoryModules {
		for category, categoryModules := range categories {
			// Collect all tags from module files
			tagMap := make(map[string]bool)

			// Add platform and category tags to ensure they're always present
			tagMap[platform] = true
			tagMap[platform+"_"+category] = true
			tagMap["all"] = true

			// Add all tags from module files
			for _, module := range categoryModules {
				for _, tag := range module.BuildTags {
					if tag != "" {
						tagMap[tag] = true
					}
				}
			}

			// Convert map to slice
			var allTags []string
			for tag := range tagMap {
				allTags = append(allTags, tag)
			}

			// Sort the tags for consistency
			sort.Strings(allTags)

			// Join tags with " || "
			tagExpr := strings.Join(allTags, " || ")

			// Create file data
			data := struct {
				Platform string
				Category string
				TagExpr  string
			}{
				Platform: platform,
				Category: category,
				TagExpr:  tagExpr,
			}

			// Parse template
			tmpl, err := template.New("cmdfile").Parse(cmdFileTemplate)
			if err != nil {
				return err
			}

			// Determine the cmd file name
			filename := filepath.Join(cmdDir, fmt.Sprintf("%s_%s.go", platform, category))

			// Check if file already exists
			var file *os.File
			if _, err := os.Stat(filename); err == nil {
				// File exists, we need to update it
				// Read existing file to check if content would change
				existingContent, err := os.ReadFile(filename)
				if err != nil {
					return fmt.Errorf("failed to read existing cmd file %s: %v", filename, err)
				}

				// Render new content to buffer
				var buf bytes.Buffer
				if err := tmpl.Execute(&buf, data); err != nil {
					return err
				}

				// If content is the same, skip updating
				if string(existingContent) == buf.String() {
					fmt.Printf("Cmd file up to date: %s\n", filename)
					continue
				}

				// Content would change, open file for writing
				file, err = os.Create(filename)
				if err != nil {
					return err
				}
			} else {
				// File doesn't exist, create it
				file, err = os.Create(filename)
				if err != nil {
					return err
				}
			}

			// Execute template and write to file
			if err := tmpl.Execute(file, data); err != nil {
				file.Close()
				return err
			}

			file.Close()
			fmt.Printf("Updated cmd file: %s\n", filename)
		}
	}

	return nil
}

// uniqueSortedStrings returns a new slice with unique sorted strings
func uniqueSortedStrings(strings []string) []string {
	// Create a map to remove duplicates
	uniqueMap := make(map[string]bool)
	for _, s := range strings {
		uniqueMap[s] = true
	}

	// Convert back to slice
	result := make([]string, 0, len(uniqueMap))
	for s := range uniqueMap {
		result = append(result, s)
	}

	// Sort the slice
	sort.Strings(result)

	return result
}
